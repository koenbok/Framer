// Generated by CoffeeScript 1.9.3
var Screen, Utils, _, __domComplete, __domReady, _textSizeNode,
  indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
  slice = [].slice;

_ = require("./Underscore")._;

Screen = require("./Screen").Screen;

Utils = {};

Utils.reset = function() {
  return Framer.CurrentContext.reset();
};

Utils.getValue = function(value) {
  if (_.isFunction(value)) {
    return value();
  }
  return value;
};

Utils.getValueForKeyPath = function(obj, key) {
  var len, m, ref, ref1, result;
  result = obj;
  if (ref = !".", indexOf.call(key, ref) >= 0) {
    return obj[key];
  }
  ref1 = key.split(".");
  for (m = 0, len = ref1.length; m < len; m++) {
    key = ref1[m];
    result = result[key];
  }
  return result;
};

Utils.setValueForKeyPath = function(obj, path, val) {
  var field, fields, i, n, result;
  fields = path.split('.');
  result = obj;
  i = 0;
  n = fields.length;
  while (i < n && result !== void 0) {
    field = fields[i];
    if (i === n - 1) {
      result[field] = val;
    } else {
      if (typeof result[field] === 'undefined' || !_.isObject(result[field])) {
        result[field] = {};
      }
      result = result[field];
    }
    i++;
  }
};

Utils.valueOrDefault = function(value, defaultValue) {
  if (value === (void 0) || value === null) {
    value = defaultValue;
  }
  return value;
};

Utils.arrayNext = function(arr, item) {
  return arr[arr.indexOf(item) + 1] || _.first(arr);
};

Utils.arrayPrev = function(arr, item) {
  return arr[arr.indexOf(item) - 1] || _.last(arr);
};

Utils.sum = function(arr) {
  return _.reduce(arr, function(a, b) {
    return a + b;
  });
};

Utils.average = function(arr) {
  return Utils.sum(arr) / arr.length;
};

Utils.mean = Utils.average;

Utils.median = function(x) {
  var sorted;
  if (x.length === 0) {
    return null;
  }
  sorted = x.slice().sort(function(a, b) {
    return a - b;
  });
  if (sorted.length % 2 === 1) {
    return sorted[(sorted.length - 1) / 2];
  } else {
    return (sorted[(sorted.length / 2) - 1] + sorted[sorted.length / 2]) / 2;
  }
};

if (window.requestAnimationFrame == null) {
  window.requestAnimationFrame = window.webkitRequestAnimationFrame;
}

if (window.requestAnimationFrame == null) {
  window.requestAnimationFrame = function(f) {
    return Utils.delay(1 / 60, f);
  };
}

if (window.performance) {
  Utils.getTime = function() {
    return window.performance.now() / 1000;
  };
} else {
  Utils.getTime = function() {
    return Date.now() / 1000;
  };
}

Utils.delay = function(time, f) {
  var timer;
  timer = setTimeout(f, time * 1000);
  Framer.CurrentContext._delayTimers.push(timer);
  return timer;
};

Utils.interval = function(time, f) {
  var timer;
  timer = setInterval(f, time * 1000);
  Framer.CurrentContext._delayIntervals.push(timer);
  return timer;
};

Utils.debounce = function(threshold, fn, immediate) {
  var timeout;
  if (threshold == null) {
    threshold = 0.1;
  }
  timeout = null;
  threshold *= 1000;
  return function() {
    var args, delayed, obj;
    args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
    obj = this;
    delayed = function() {
      if (!immediate) {
        fn.apply(obj, args);
      }
      return timeout = null;
    };
    if (timeout) {
      clearTimeout(timeout);
    } else if (immediate) {
      fn.apply(obj, args);
    }
    return timeout = setTimeout(delayed, threshold);
  };
};

Utils.throttle = function(delay, fn) {
  var timer;
  if (delay === 0) {
    return fn;
  }
  delay *= 1000;
  timer = false;
  return function() {
    if (timer) {
      return;
    }
    timer = true;
    if (delay !== -1) {
      setTimeout((function() {
        return timer = false;
      }), delay);
    }
    return fn.apply(null, arguments);
  };
};

Utils.memoize = function(fn) {
  return function() {
    var args, currentArg, hash, i;
    args = Array.prototype.slice.call(arguments);
    hash = "";
    i = args.length;
    currentArg = null;
    while (i--) {
      currentArg = args[i];
      hash += (currentArg === Object(currentArg) ? JSON.stringify(currentArg) : currentArg);
      fn.memoize || (fn.memoize = {});
    }
    if (hash in fn.memoize) {
      return fn.memoize[hash];
    } else {
      return fn.memoize[hash] = fn.apply(this, args);
    }
  };
};

Utils.randomColor = function(alpha) {
  var c;
  if (alpha == null) {
    alpha = 1.0;
  }
  c = function() {
    return parseInt(Math.random() * 255);
  };
  return "rgba(" + (c()) + ", " + (c()) + ", " + (c()) + ", " + alpha + ")";
};

Utils.randomChoice = function(arr) {
  return arr[Math.floor(Math.random() * arr.length)];
};

Utils.randomNumber = function(a, b) {
  if (a == null) {
    a = 0;
  }
  if (b == null) {
    b = 1;
  }
  return Utils.mapRange(Math.random(), 0, 1, a, b);
};

Utils.defineEnum = function(names, offset, geometric) {
  var Enum, i, j, len, m, name;
  if (names == null) {
    names = [];
  }
  if (offset == null) {
    offset = 0;
  }
  if (geometric == null) {
    geometric = 0;
  }
  Enum = {};
  for (i = m = 0, len = names.length; m < len; i = ++m) {
    name = names[i];
    j = i;
    j = !offset ? j : j + offset;
    j = !geometric ? j : Math.pow(geometric, j);
    Enum[Enum[name] = j] = name;
  }
  return Enum;
};

Utils.labelLayer = function(layer, text, style) {
  if (style == null) {
    style = {};
  }
  style = _.extend({
    font: "10px/1em Menlo",
    lineHeight: layer.height + "px",
    textAlign: "center",
    color: "#fff"
  }, style);
  layer.style = style;
  return layer.html = text;
};

Utils.stringify = function(obj) {
  try {
    if (_.isObject(obj)) {
      return JSON.stringify(obj);
    }
  } catch (_error) {
    "";
  }
  if (obj === null) {
    return "null";
  }
  if (obj === void 0) {
    return "undefined";
  }
  if (obj.toString) {
    return obj.toString();
  }
  return obj;
};

Utils.inspectObjectType = function(item) {
  var className, extract, ref, ref1, ref2;
  if ((((ref = item.constructor) != null ? ref.name : void 0) != null) && ((ref1 = item.constructor) != null ? ref1.name : void 0) !== "Object") {
    return item.constructor.name;
  }
  extract = function(str) {
    var match, regex;
    if (!str) {
      return null;
    }
    regex = /\[object (\w+)\]/;
    match = regex.exec(str);
    if (match) {
      return match[1];
    }
    return null;
  };
  className = extract(item.toString());
  if (className) {
    return className;
  }
  className = extract((ref2 = item.constructor) != null ? ref2.toString() : void 0);
  if (className) {
    return className.replace("Constructor", "");
  }
  return item;
};

Utils.inspect = function(item, max, l) {
  var code, limit, objectInfo, objectType;
  if (max == null) {
    max = 5;
  }
  if (l == null) {
    l = 0;
  }
  if (item === null) {
    return "null";
  }
  if (item === void 0) {
    return "undefined";
  }
  if (_.isFunction(item.toInspect)) {
    return item.toInspect();
  }
  if (_.isString(item)) {
    return "\"" + item + "\"";
  }
  if (_.isNumber(item)) {
    return "" + item;
  }
  if (_.isFunction(item)) {
    code = item.toString().slice("function ".length).replace(/\n/g, "").replace(/\s+/g, " ");
    limit = 50;
    if (code.length > limit && l > 0) {
      code = (_.trimRight(code.slice(0, +limit + 1 || 9e9))) + "â€¦ }";
    }
    return "<Function " + code + ">";
  }
  if (_.isArray(item)) {
    if (l > max) {
      return "[...]";
    }
    return "[" + _.map(item, function(i) {
      return Utils.inspect(i, max, l + 1);
    }).join(", ") + "]";
  }
  if (_.isObject(item)) {
    objectType = Utils.inspectObjectType(item);
    if (/HTML\w+?Element/.test(objectType)) {
      return "<" + objectType + ">";
    }
    if (l > max) {
      objectInfo = "{...}";
    } else {
      objectInfo = "{" + _.map(item, function(v, k) {
        return k + ":" + (Utils.inspect(v, max, l + 1));
      }).join(", ") + "}";
    }
    if (objectType === "Object") {
      return objectInfo;
    }
    return "<" + objectType + " " + objectInfo + ">";
  }
  return "" + item;
};

Utils.uuid = function() {
  var chars, digit, m, output, r, random;
  chars = "0123456789abcdefghijklmnopqrstuvwxyz".split("");
  output = new Array(36);
  random = 0;
  for (digit = m = 1; m <= 32; digit = ++m) {
    if (random <= 0x02) {
      random = 0x2000000 + (Math.random() * 0x1000000) | 0;
    }
    r = random & 0xf;
    random = random >> 4;
    output[digit] = chars[digit === 19 ? (r & 0x3) | 0x8 : r];
  }
  return output.join("");
};

Utils.arrayFromArguments = function(args) {
  if (_.isArray(args[0])) {
    return args[0];
  }
  return Array.prototype.slice.call(args);
};

Utils.cycle = function() {
  var args, curr;
  args = Utils.arrayFromArguments(arguments);
  curr = -1;
  return function() {
    curr++;
    if (curr >= args.length) {
      curr = 0;
    }
    return args[curr];
  };
};

Utils.toggle = Utils.cycle;

Utils.isWebKit = function() {
  return window.WebKitCSSMatrix !== void 0;
};

Utils.webkitVersion = function() {
  var regexp, result, version;
  version = -1;
  regexp = /AppleWebKit\/([\d.]+)/;
  result = regexp.exec(navigator.userAgent);
  if (result) {
    version = parseFloat(result[1]);
  }
  return version;
};

Utils.isChrome = function() {
  return /chrome/.test(navigator.userAgent.toLowerCase());
};

Utils.isSafari = function() {
  return /safari/.test(navigator.userAgent.toLowerCase());
};

Utils.isTouch = function() {
  return window.ontouchstart === null;
};

Utils.isDesktop = function() {
  return Utils.deviceType() === "desktop";
};

Utils.isPhone = function() {
  return Utils.deviceType() === "phone";
};

Utils.isTablet = function() {
  return Utils.deviceType() === "tablet";
};

Utils.isMobile = function() {
  return Utils.isPhone() || Utils.isTablet();
};

Utils.isLocal = function() {
  return Utils.isLocalUrl(window.location.href);
};

Utils.isLocalUrl = function(url) {
  return url.slice(0, 7) === "file://";
};

Utils.isFramerStudio = function() {
  return navigator.userAgent.indexOf("FramerStudio") !== -1;
};

Utils.devicePixelRatio = function() {
  return window.devicePixelRatio;
};

Utils.isJP2Supported = function() {
  return Utils.isWebKit() && !Utils.isChrome();
};

Utils.deviceType = function() {
  if (/(tablet)|(iPad)|(Nexus 9)/i.test(navigator.userAgent)) {
    return "tablet";
  }
  if (/(mobi)/i.test(navigator.userAgent)) {
    return "phone";
  }
  return "desktop";
};

Utils.pathJoin = function() {
  return Utils.arrayFromArguments(arguments).join("/");
};

Utils.round = function(value, decimals) {
  var d;
  if (decimals == null) {
    decimals = 0;
  }
  d = Math.pow(10, decimals);
  return Math.round(value * d) / d;
};

Utils.clamp = function(value, a, b) {
  var max, min;
  min = Math.min(a, b);
  max = Math.max(a, b);
  if (value < min) {
    value = min;
  }
  if (value > max) {
    value = max;
  }
  return value;
};

Utils.mapRange = function(value, fromLow, fromHigh, toLow, toHigh) {
  return toLow + (((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow));
};

Utils.modulate = function(value, rangeA, rangeB, limit) {
  var fromHigh, fromLow, result, toHigh, toLow;
  if (limit == null) {
    limit = false;
  }
  fromLow = rangeA[0], fromHigh = rangeA[1];
  toLow = rangeB[0], toHigh = rangeB[1];
  result = toLow + (((value - fromLow) / (fromHigh - fromLow)) * (toHigh - toLow));
  if (limit === true) {
    if (toLow < toHigh) {
      if (result < toLow) {
        return toLow;
      }
      if (result > toHigh) {
        return toHigh;
      }
    } else {
      if (result > toLow) {
        return toLow;
      }
      if (result < toHigh) {
        return toHigh;
      }
    }
  }
  return result;
};

Utils.parseFunction = function(str) {
  var result;
  result = {
    name: "",
    args: []
  };
  if (_.endsWith(str, ")")) {
    result.name = str.split("(")[0];
    result.args = str.split("(")[1].split(",").map(function(a) {
      return _.trim(_.trimRight(a, ")"));
    });
  } else {
    result.name = str;
  }
  return result;
};

__domComplete = [];

__domReady = false;

if (typeof document !== "undefined" && document !== null) {
  document.onreadystatechange = (function(_this) {
    return function(event) {
      var f, results;
      if (document.readyState === "complete") {
        __domReady = true;
        results = [];
        while (__domComplete.length) {
          results.push(f = __domComplete.shift()());
        }
        return results;
      }
    };
  })(this);
}

Utils.domComplete = function(f) {
  if (document.readyState === "complete") {
    return f();
  } else {
    return __domComplete.push(f);
  }
};

Utils.domCompleteCancel = function(f) {
  return __domComplete = _.without(__domComplete, f);
};

Utils.domLoadScript = function(url, callback) {
  var head, script;
  script = document.createElement("script");
  script.type = "text/javascript";
  script.src = url;
  script.onload = callback;
  head = document.getElementsByTagName("head")[0];
  head.appendChild(script);
  return script;
};

Utils.domLoadData = function(path, callback) {
  var request;
  request = new XMLHttpRequest();
  request.addEventListener("load", function() {
    return callback(null, request.responseText);
  }, false);
  request.addEventListener("error", function() {
    return callback(true, null);
  }, false);
  request.open("GET", path, true);
  return request.send(null);
};

Utils.domLoadJSON = function(path, callback) {
  return Utils.domLoadData(path, function(err, data) {
    return callback(err, JSON.parse(data));
  });
};

Utils.domLoadDataSync = function(path) {
  var e, handleError, ref, request;
  request = new XMLHttpRequest();
  request.open("GET", path, false);
  try {
    request.send(null);
  } catch (_error) {
    e = _error;
    console.debug("XMLHttpRequest.error", e);
  }
  handleError = function() {
    throw Error("Utils.domLoadDataSync: " + path + " -> [" + request.status + " " + request.statusText + "]");
  };
  request.onerror = handleError;
  if ((ref = request.status) !== 200 && ref !== 0) {
    handleError();
  }
  if (!request.responseText) {
    handleError();
  }
  return request.responseText;
};

Utils.domLoadJSONSync = function(path) {
  return JSON.parse(Utils.domLoadDataSync(path));
};

Utils.domLoadScriptSync = function(path) {
  var scriptData;
  scriptData = Utils.domLoadDataSync(path);
  eval(scriptData);
  return scriptData;
};

Utils.insertCSS = function(css) {
  var styleElement;
  styleElement = document.createElement("style");
  styleElement.type = "text/css";
  styleElement.innerHTML = css;
  return Utils.domComplete(function() {
    return document.body.appendChild(styleElement);
  });
};

Utils.loadImage = function(url, callback, context) {
  var element;
  element = new Image;
  if (context == null) {
    context = Framer.CurrentContext;
  }
  context.eventManager.wrap(element).addEventListener("load", function(event) {
    return callback();
  });
  context.eventManager.wrap(element).addEventListener("error", function(event) {
    return callback(true);
  });
  return element.src = url;
};

Utils.pointZero = function(args) {
  if (args == null) {
    args = {};
  }
  return _.defaults(args, {
    x: 0,
    y: 0
  });
};

Utils.pointMin = function() {
  var point, points;
  points = Utils.arrayFromArguments(arguments);
  return point = {
    x: _.min(points.map(function(size) {
      return size.x;
    })),
    y: _.min(points.map(function(size) {
      return size.y;
    }))
  };
};

Utils.pointMax = function() {
  var point, points;
  points = Utils.arrayFromArguments(arguments);
  return point = {
    x: _.max(points.map(function(size) {
      return size.x;
    })),
    y: _.max(points.map(function(size) {
      return size.y;
    }))
  };
};

Utils.pointDistance = function(pointA, pointB) {
  var distance;
  return distance = {
    x: Math.abs(pointB.x - pointA.x),
    y: Math.abs(pointB.y - pointA.y)
  };
};

Utils.pointInvert = function(point) {
  return point = {
    x: 0 - point.x,
    y: 0 - point.y
  };
};

Utils.pointTotal = function(point) {
  return point.x + point.y;
};

Utils.pointAbs = function(point) {
  return point = {
    x: Math.abs(point.x),
    y: Math.abs(point.y)
  };
};

Utils.pointInFrame = function(point, frame) {
  if (point.x < Utils.frameGetMinX(frame) || point.x > Utils.frameGetMaxX(frame)) {
    return false;
  }
  if (point.y < Utils.frameGetMinY(frame) || point.y > Utils.frameGetMaxY(frame)) {
    return false;
  }
  return true;
};

Utils.sizeZero = function(args) {
  if (args == null) {
    args = {};
  }
  return _.defaults(args, {
    width: 0,
    height: 0
  });
};

Utils.sizeMin = function() {
  var size, sizes;
  sizes = Utils.arrayFromArguments(arguments);
  return size = {
    width: _.min(sizes.map(function(size) {
      return size.width;
    })),
    height: _.min(sizes.map(function(size) {
      return size.height;
    }))
  };
};

Utils.sizeMax = function() {
  var size, sizes;
  sizes = Utils.arrayFromArguments(arguments);
  return size = {
    width: _.max(sizes.map(function(size) {
      return size.width;
    })),
    height: _.max(sizes.map(function(size) {
      return size.height;
    }))
  };
};

Utils.rectZero = function(args) {
  if (args == null) {
    args = {};
  }
  return _.defaults(args, {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  });
};

Utils.parseRect = function(args) {
  if (_.isArray(args) && _.isNumber(args[0])) {
    if (args.length === 1) {
      return Utils.parseRect({
        top: args[0]
      });
    }
    if (args.length === 2) {
      return Utils.parseRect({
        top: args[0],
        right: args[1]
      });
    }
    if (args.length === 3) {
      return Utils.parseRect({
        top: args[0],
        right: args[1],
        bottom: args[2]
      });
    }
    if (args.length === 4) {
      return Utils.parseRect({
        top: args[0],
        right: args[1],
        bottom: args[2],
        left: args[3]
      });
    }
  }
  if (_.isArray(args) && _.isObject(args[0])) {
    return args[0];
  }
  if (_.isObject(args)) {
    return args;
  }
  return {};
};

Utils.frameGetMinX = function(frame) {
  return frame.x;
};

Utils.frameSetMinX = function(frame, value) {
  return frame.x = value;
};

Utils.frameGetMidX = function(frame) {
  if (frame.width === 0) {
    return 0;
  } else {
    return frame.x + (frame.width / 2.0);
  }
};

Utils.frameSetMidX = function(frame, value) {
  return frame.x = frame.width === 0 ? 0 : value - (frame.width / 2.0);
};

Utils.frameGetMaxX = function(frame) {
  if (frame.width === 0) {
    return 0;
  } else {
    return frame.x + frame.width;
  }
};

Utils.frameSetMaxX = function(frame, value) {
  return frame.x = frame.width === 0 ? 0 : value - frame.width;
};

Utils.frameGetMinY = function(frame) {
  return frame.y;
};

Utils.frameSetMinY = function(frame, value) {
  return frame.y = value;
};

Utils.frameGetMidY = function(frame) {
  if (frame.height === 0) {
    return 0;
  } else {
    return frame.y + (frame.height / 2.0);
  }
};

Utils.frameSetMidY = function(frame, value) {
  return frame.y = frame.height === 0 ? 0 : value - (frame.height / 2.0);
};

Utils.frameGetMaxY = function(frame) {
  if (frame.height === 0) {
    return 0;
  } else {
    return frame.y + frame.height;
  }
};

Utils.frameSetMaxY = function(frame, value) {
  return frame.y = frame.height === 0 ? 0 : value - frame.height;
};

Utils.frameZero = function(args) {
  if (args == null) {
    args = {};
  }
  return _.defaults(args, {
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  });
};

Utils.frameSize = function(frame) {
  var size;
  return size = {
    width: frame.width,
    height: frame.height
  };
};

Utils.framePoint = function(frame) {
  var point;
  return point = {
    x: frame.x,
    y: frame.y
  };
};

Utils.frameMerge = function() {
  var frame, frames;
  frames = Utils.arrayFromArguments(arguments);
  frame = {
    x: _.min(frames.map(Utils.frameGetMinX)),
    y: _.min(frames.map(Utils.frameGetMinY))
  };
  frame.width = _.max(frames.map(Utils.frameGetMaxX)) - frame.x;
  frame.height = _.max(frames.map(Utils.frameGetMaxY)) - frame.y;
  return frame;
};

Utils.framePointForOrigin = function(frame, originX, originY) {
  return frame = {
    x: frame.x + (originX * frame.width),
    y: frame.y + (originY * frame.height),
    width: frame.width,
    height: frame.height
  };
};

Utils.frameInset = function(frame, inset) {
  return frame = {
    x: frame.x + inset.left,
    y: frame.y + inset.top,
    width: frame.width - inset.left - inset.right,
    height: frame.height - inset.top - inset.bottom
  };
};

Utils.frameSortByAbsoluteDistance = function(point, frames, originX, originY) {
  var distance;
  if (originX == null) {
    originX = 0;
  }
  if (originY == null) {
    originY = 0;
  }
  distance = function(frame) {
    var result;
    result = Utils.pointDistance(point, Utils.framePointForOrigin(frame, originX, originY));
    result = Utils.pointAbs(result);
    result = Utils.pointTotal(result);
    return result;
  };
  return frames.sort(function(a, b) {
    return distance(a) - distance(b);
  });
};

Utils.pointInPolygon = function(point, vs) {
  var i, inside, intersect, j, x, xi, xj, y, yi, yj;
  x = point[0];
  y = point[1];
  inside = false;
  i = 0;
  j = vs.length - 1;
  while (i < vs.length) {
    xi = vs[i][0];
    yi = vs[i][1];
    xj = vs[j][0];
    yj = vs[j][1];
    intersect = ((yi > y && y !== yj) && yj > y) && x < (xj - xi) * (y - yi) / (yj - yi) + xi;
    if (intersect) {
      inside = !inside;
    }
    j = i++;
  }
  return inside;
};

Utils.pointAngle = function(p1, p2) {
  return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI;
};

Utils.convertPoint = function(input, layerA, layerB, context) {
  var layer, len, len1, m, o, point, superLayersA, superLayersB;
  if (context == null) {
    context = false;
  }
  point = _.defaults(input, {
    x: 0,
    y: 0
  });
  superLayersA = (layerA != null ? layerA.superLayers(context) : void 0) || [];
  superLayersB = (layerB != null ? layerB.superLayers(context) : void 0) || [];
  if (layerB) {
    superLayersB.push(layerB);
  }
  for (m = 0, len = superLayersA.length; m < len; m++) {
    layer = superLayersA[m];
    point.x += layer.x;
    point.y += layer.y;
  }
  for (o = 0, len1 = superLayersB.length; o < len1; o++) {
    layer = superLayersB[o];
    point.x -= layer.x;
    point.y -= layer.y;
  }
  return point;
};

Utils.globalLayers = function(importedLayers) {
  var layer, layerName;
  for (layerName in importedLayers) {
    layer = importedLayers[layerName];
    layerName = layerName.replace(/\s/g, "");
    if (window.hasOwnProperty(layerName) && !window.Framer._globalWarningGiven) {
      print("Warning: Cannot make layer '" + layerName + "' a global, a variable with that name already exists");
    } else {
      window[layerName] = layer;
    }
  }
  return window.Framer._globalWarningGiven = true;
};

_textSizeNode = null;

Utils.textSize = function(text, style, constraints) {
  var frame, rect, shouldCreateNode;
  if (style == null) {
    style = {};
  }
  if (constraints == null) {
    constraints = {};
  }
  shouldCreateNode = !_textSizeNode;
  if (shouldCreateNode) {
    _textSizeNode = document.createElement("div");
    _textSizeNode.id = "_textSizeNode";
  }
  _textSizeNode.removeAttribute("style");
  _textSizeNode.innerHTML = text;
  style = _.extend(_.clone(style), {
    position: "fixed",
    display: "inline",
    visibility: "hidden",
    top: "-10000px",
    left: "-10000px"
  });
  delete style.width;
  delete style.height;
  delete style.bottom;
  delete style.right;
  if (constraints.width) {
    style.width = constraints.width + "px";
  }
  if (constraints.height) {
    style.height = constraints.height + "px";
  }
  _.extend(_textSizeNode.style, style);
  if (shouldCreateNode) {
    if (!window.document.body) {
      document.write(_textSizeNode.outerHTML);
      _textSizeNode = document.getElementById("_textSizeNode");
    } else {
      window.document.body.appendChild(_textSizeNode);
    }
  }
  rect = _textSizeNode.getBoundingClientRect();
  return frame = {
    width: rect.right - rect.left,
    height: rect.bottom - rect.top
  };
};

_.extend(exports, Utils);
